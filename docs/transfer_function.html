
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>3. Tutorial: Measuring a transfer function (demonstrates the core functionalities) &#8212; Connectors 1.0 documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="4. Reference: Macro connectors for encapsulating processing networks in a class" href="macro_reference.html" />
    <link rel="prev" title="2. Reference: The core functionalities" href="core_reference.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="macro_reference.html" title="4. Reference: Macro connectors for encapsulating processing networks in a class"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="core_reference.html" title="2. Reference: The core functionalities"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Connectors 1.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tutorial-measuring-a-transfer-function-demonstrates-the-core-functionalities">
<h1>3. Tutorial: Measuring a transfer function (demonstrates the core functionalities)<a class="headerlink" href="#tutorial-measuring-a-transfer-function-demonstrates-the-core-functionalities" title="Permalink to this headline">¶</a></h1>
<p>This tutorial walks through a simple example of determining a transfer function with processing objects, that are connected with the functionalities of the <em>Connectors</em> package.</p>
<div class="section" id="what-s-a-transfer-function">
<h2>3.1. What’s a transfer function<a class="headerlink" href="#what-s-a-transfer-function" title="Permalink to this headline">¶</a></h2>
<p>A transfer function describes, how a linear, time-invariant system amplifies and delays the frequency components of its input signal.
Examples of such systems are equalizers of HiFi systems, which allow to tweak the system’s sound by boosting or attenuating certain frequency regions.
Or radio tuners, which supress all frequencies except for the one of the channel, that shall be received.
The reflections and reverberations of a concert hall, which a listener experiences when attending an event there, can also be described by a transfer function.</p>
<p>The transfer function of a system can be measured by sending a known input signal into the system and recording its response.
After that, the spectrum of this response has to be divided by the spectrum of the input signal.
Think of this as of compensating for a bias of the input signal, which might excite certain frequencies at a higher level than others.
If this is the case, the recorded response will also have an exaggerated amount of these frequency components, which is not due them being boosted by the system, but due to a biased excitation.
The divison normalizes the response by attenuating the frequency components, that had been exaggerated in the excitation signal.</p>
<p>Of course, the exctiation signal has to excite all frequencies, at which the system shall be modeled.
Otherwise, the division will divide by zero and the resulting transfer function will be invalid at the non-excited frequencies.</p>
<dl class="docutils">
<dt>For more background on transfer functions, you can read the following Wikipedia articles (sorted in increasing order of theoretical complexity):</dt>
<dd><ul class="first last simple">
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Frequency_response">Frequency response</a></li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Transfer_function">Transfer function</a></li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Linear_time-invariant_theory">Linear time-invariant theory</a></li>
</ul>
</dd>
</dl>
<p>The following block diagram shows the computation steps for determining the transfer function of a system:</p>
<img src="_images/graphviz-c96a534effa3c700593e3bc12c1b148d0575399d.png" alt="digraph Measurement{
   rankdir=LR;
   generator -&gt; system -&gt; fft1 -&gt; division -&gt; plot;
   generator -&gt; fft2 -&gt; division;
   generator [label=&quot;Signal generator&quot;, shape=hexagon];
   system [label=&quot;{|System|}&quot;, shape=record, color=red];
   fft1 [label=&quot;FFT 1&quot;, shape=box, color=blue];
   division [label=&quot;÷&quot;, shape=box, color=blue];
   fft2 [label=&quot;FFT 2&quot;, shape=box, color=blue];
   plot [label=&quot;Plot&quot;, shape=parallelogram];
   {rank=same; fft1, fft2};
}" />
<p>First, the excitation signal is created in <em>Signal generator</em>.
In this tutorial, a linear sweep is used, which is a sine wave, which continuously increases its frequency over time, thus exciting all the frequencies at which the system shall be modeled.
The sweep is used, because it is mathematically well defined, easy to implement and for demonstrating what will happen, if the frequency range of the excitation signal is limited.
For the purpose of measuring a transfer function, other signals such as noise or maximum length sequences are also suitable.</p>
<p>The generated excitation signal is fed into the <em>System</em>.
The spectrum of the system’s response is computed by transforming the response to the frequency domain with the help of the fast fourier transform in block <em>FFT 1</em>.
Meanwhile, the spectrum of the excitation signal is computed by the block <em>FFT 2</em>.
The resulting transfer function is computed by the division <em>÷</em> and displayed by the <em>Plot</em>.</p>
</div>
<div class="section" id="define-a-system-of-which-the-tranfer-function-shall-be-measured">
<h2>3.2. Define a system, of which the tranfer function shall be measured<a class="headerlink" href="#define-a-system-of-which-the-tranfer-function-shall-be-measured" title="Permalink to this headline">¶</a></h2>
<p>For reducing the lines of code for this tutorial, the system, that shall be analyzed by measuring its transfer function, is modeled with its impulse response.
The impulse response is mathematically connected to the transfer function by the (inverse) fourier transform.</p>
<img src="_images/graphviz-b780df403924a724bcc5a12c588d8c37acb505c3.png" alt="digraph ImpulseResponse{
   rankdir=LR;
   ir -&gt; fft -&gt; tf -&gt; ifft -&gt; ir;
   ir [label=&quot;impulse response&quot;, shape=hexagon];
   fft [label=&quot;Fourier transform&quot;, shape=box];
   tf [label=&quot;transfer function&quot;, shape=hexagon];
   ifft [label=&quot;inverse Fourier transform&quot;, shape=box];
   {rank=same; fft, ifft};
}" />
<p>The following code implements a class for defining a linear time-invariant system.
It requires an impulse response as constructor parameter, in order to define the system’s behavior.
Furthermore it has a setter and a getter method for passing the excitation signal and retrieving the response.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LinearSystem</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">impulse_response</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__impulse_response</span> <span class="o">=</span> <span class="n">impulse_response</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__input</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="nd">@connectors.Input</span><span class="p">(</span><span class="s2">&quot;get_output&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__input</span> <span class="o">=</span> <span class="n">signal</span>

    <span class="nd">@connectors.Output</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">get_output</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__impulse_response</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__input</span><span class="p">)]</span>
</pre></div>
</div>
<p>The setter method <code class="xref py py-meth docutils literal"><span class="pre">set_input()</span></code> is decorated to become an input connector, so that the output of the generator of the excitation signal can be connected to it.
Note that the name of the getter method <code class="xref py py-meth docutils literal"><span class="pre">get_output()</span></code> is passed as a parameter to the input decorator.
This models the dependency of the getter’s return value on whether the setter has been called.
So whenever a new value is passed to the setter, the getter is notified, that it can produce a new result.</p>
<p>The getter method <code class="xref py py-meth docutils literal"><span class="pre">get_output()</span></code> is decorated to become an output connector.
Note that this is the method, that actually does the expensive computation, while the setter only stores the received parameter.
This is a recommended practice when using the <em>Connectors</em> package, since the lazy execution and the caching capability of the output connectors can avoid, that these computations are performed unnecessarily.</p>
</div>
<div class="section" id="generate-a-measurement-signal">
<h2>3.3. Generate a measurement signal<a class="headerlink" href="#generate-a-measurement-signal" title="Permalink to this headline">¶</a></h2>
<p>Using the <em>Connectors</em> package with the generator class for the linear sweep is straight forward.
In production code, all parameters, that can be passed to the constructor, should have a setter method, that is decorated to become an input connector.
This has been omitted in this tutorial to keep the code short.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SweepGenerator</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_frequency</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span> <span class="n">stop_frequency</span><span class="o">=</span><span class="mf">20000.0</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__start_frequency</span> <span class="o">=</span> <span class="n">start_frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__stop_frequency</span> <span class="o">=</span> <span class="n">stop_frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__length</span> <span class="o">=</span> <span class="n">length</span>

    <span class="nd">@connectors.Input</span><span class="p">(</span><span class="s2">&quot;get_sweep&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_start_frequency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequency</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__start_frequency</span> <span class="o">=</span> <span class="n">frequency</span>

    <span class="nd">@connectors.Output</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">get_sweep</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">f0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__start_frequency</span>
        <span class="n">fT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stop_frequency</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__length</span> <span class="o">/</span> <span class="n">sampling_rate</span>               <span class="c1"># the duration of the signal</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">sampling_rate</span><span class="p">)</span>   <span class="c1"># an array with the time samples</span>
        <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">fT</span> <span class="o">-</span> <span class="n">f0</span><span class="p">)</span> <span class="o">/</span> <span class="n">T</span>                               <span class="c1"># the &quot;sweep rate&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">f0</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="compute-the-fourier-transform">
<h2>3.4. Compute the fourier transform<a class="headerlink" href="#compute-the-fourier-transform" title="Permalink to this headline">¶</a></h2>
<p>Decorating the methods of the class for the fourier transform works just like in the previous classes.
But the deletion of the input signal in the getter method <code class="xref py py-meth docutils literal"><span class="pre">get_spectrum()</span></code> is noteworthy.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FourierTransform</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__signal</span> <span class="o">=</span> <span class="n">signal</span>

    <span class="nd">@connectors.Input</span><span class="p">(</span><span class="s2">&quot;get_spectrum&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__signal</span> <span class="o">=</span> <span class="n">signal</span>

    <span class="nd">@connectors.Output</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">get_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__signal</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__signal</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">spectrum</span>
</pre></div>
</div>
<p>Since the input signal is the only parameter for the fourier transform, the reference to it can be deleted after computing the output spectrum, as long as the caching of the output spectrum is enabled.
The only situation, in which the cached spectrum becomes invalid and the output spectrum has to be recomputed, is when a new input signal is provided.
So the old input signal is no longer needed after the computation.</p>
<p>In this example, the input signals for the two fourier transform classes would not be garbage collected, because they are cached in the outputs of the signal generator and the system under test.
The memory requirements for running the script of this tutorial are moderate, so that the code has not been optimized for minimal memory consumption by deactivating caching and other measures.
In some practical situations, these optimizations can reduce the memory consumption significantly.</p>
</div>
<div class="section" id="compute-the-transfer-function">
<h2>3.5. Compute the transfer function<a class="headerlink" href="#compute-the-transfer-function" title="Permalink to this headline">¶</a></h2>
<p>The class, that computes the transfer function by dividing the response spectrum by the excitation spectrum is again straight forward.
The only difference, that has not been shown in previous classes is, that an output connector depends on the parameters of multiple input connectors.
Each of these receives the name of the dependent output connector as a parameter for the <a class="reference internal" href="core_reference.html#connectors.Input" title="connectors.Input"><code class="xref py py-class docutils literal"><span class="pre">Input</span></code></a> decorator.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TransferFunction</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">excitation</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">response</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__excitation</span> <span class="o">=</span> <span class="n">excitation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__response</span> <span class="o">=</span> <span class="n">response</span>

    <span class="nd">@connectors.Input</span><span class="p">(</span><span class="s2">&quot;get_transfer_function&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_excitation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__excitation</span> <span class="o">=</span> <span class="n">signal</span>

    <span class="nd">@connectors.Input</span><span class="p">(</span><span class="s2">&quot;get_transfer_function&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__response</span> <span class="o">=</span> <span class="n">signal</span>

    <span class="nd">@connectors.Output</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">get_transfer_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__response</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__excitation</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="plot-the-transfer-function">
<h2>3.6. Plot the transfer function<a class="headerlink" href="#plot-the-transfer-function" title="Permalink to this headline">¶</a></h2>
<p>For the sake of simplicity, the plotting class in this tutorial only plots the magnitude of the transfer function.
Plotting the phase aswell, requires some additional functionalities of <code class="xref py py-mod docutils literal"><span class="pre">matplotlib</span></code>, which is not in the scope of this tutorial.</p>
<p>The plotting class demonstrates the use of a multi-input connector for plotting multiple spectrums in one plot.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MagnitudePlot</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__spectrums</span> <span class="o">=</span> <span class="n">connectors</span><span class="o">.</span><span class="n">MultiInputData</span><span class="p">()</span>

    <span class="nd">@connectors.MultiInput</span><span class="p">(</span><span class="s2">&quot;show&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">add_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spectrums</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>

    <span class="nd">@add_spectrum.remove</span>
    <span class="k">def</span> <span class="nf">remove_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_id</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spectrums</span><span class="p">[</span><span class="n">data_id</span><span class="p">]</span>

    <span class="nd">@add_spectrum.replace</span>
    <span class="k">def</span> <span class="nf">replace_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_id</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__spectrums</span><span class="p">[</span><span class="n">data_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">spectrum</span>

    <span class="nd">@connectors.Output</span><span class="p">(</span><span class="n">parallelization</span><span class="o">=</span><span class="n">connectors</span><span class="o">.</span><span class="n">Parallelization</span><span class="o">.</span><span class="n">SEQUENTIAL</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spectrums</span><span class="p">:</span>
            <span class="n">x_axis_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sampling_rate</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__spectrums</span><span class="p">[</span><span class="n">d</span><span class="p">]))</span>
            <span class="n">magnitude</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__spectrums</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
            <span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_axis_data</span><span class="p">,</span> <span class="n">magnitude</span><span class="p">)</span>
        <span class="n">pyplot</span><span class="o">.</span><span class="n">loglog</span><span class="p">()</span>
        <span class="n">pyplot</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mf">20.0</span><span class="p">,</span> <span class="n">sampling_rate</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
        <span class="n">pyplot</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">)</span>
        <span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Decorating the <code class="xref py py-meth docutils literal"><span class="pre">add_spectrum()</span></code> method to become a multi-input connector is similar to the regular input connectors.
It also gets the name of the dependent output connectors passed as a parameter.
It is improtant though, that the method of multi-input returns an ID, with which the added dataset can be identified, when it shall be deleted or replaced.</p>
<p>Specifying a remove-method for a multi-input connector is mandatory.
This method is called whenever a dataset is removed, for example by disconnecting an output connector from the multi-input.
Notice that the remove-method <code class="xref py py-meth docutils literal"><span class="pre">remove_spectrum()</span></code> is decorated with a method of the multi-input connector instead of an object from the <em>Connectors</em> package.</p>
<p>The replace-method <code class="xref py py-meth docutils literal"><span class="pre">replace_spectrum()</span></code> of the multi-input connector is called, whenever an added spectrum shall be replaced by an updated version.
If none is specified, the replacement will be done by removing the old dataset and adding a new one, which does not preserve the order, in which the datasets have been added.</p>
<p>The spectrums, that are added through the <code class="xref py py-meth docutils literal"><span class="pre">add_spectrum()</span></code> method are managed by a <a class="reference internal" href="helper_reference.html#connectors.MultiInputData" title="connectors.MultiInputData"><code class="xref py py-class docutils literal"><span class="pre">MultiInputData</span></code></a> container.
This is basically an <a class="reference external" href="https://docs.python.org/3.6/library/collections.html#collections.OrderedDict" title="(in Python v3.6)"><code class="xref py py-class docutils literal"><span class="pre">OrderedDict</span></code></a>, that has been extended with an <a class="reference internal" href="helper_reference.html#connectors.MultiInputData.add" title="connectors.MultiInputData.add"><code class="xref py py-meth docutils literal"><span class="pre">add()</span></code></a> method, which adds the given dataset to the dictionary and returns a unique ID, under which the dataset has been stored.</p>
<p>The <code class="xref py py-meth docutils literal"><span class="pre">show()</span></code> method is decorated to become an output connector, despite the fact that it does not return any result value.
Nevertheless, this allows to model, that showing the plot depends on the input data for the plot.</p>
<p>Note that the automated parallelization is disabled for this method by passing the flag <code class="xref py py-const docutils literal"><span class="pre">SEQUENTIAL</span></code> as the <em>parallelization</em> parameter for the output decorator.
By default, the <em>Connectors</em> package parallelizes independent computations in separate threads.
Process-based parallelization is also available, but this requires the data, that is passed through the connections, to be pickle-able and the pickling introduces additional overhead.
GUI functionalities often require, that all updates of the GUI are done by the same thread, which is why this example script will raise errors if the parallelization of the <code class="xref py py-meth docutils literal"><span class="pre">show()</span></code> method is not disabled.</p>
</div>
<div class="section" id="instantiating-the-processing-network">
<h2>3.7. Instantiating the processing network<a class="headerlink" href="#instantiating-the-processing-network" title="Permalink to this headline">¶</a></h2>
<p>Now that all the necessary processing classes are implemented, the network for measuring and computing the transfer function can be set up.</p>
<p>First the linear, time-invariant system is instantiated.
The impulse response is chosen to have a rolloff at both high and low frequencies.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>    <span class="n">impulse_response</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">impulse_response</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">system</span> <span class="o">=</span> <span class="n">LinearSystem</span><span class="p">(</span><span class="n">impulse_response</span><span class="p">)</span>

</pre></div>
</div>
<p>After that, the sweep generator is created and connected to the system, that shall be measured.
The connection is established by calling the <a class="reference internal" href="core_reference.html#connectors.connectors.OutputConnector.connect" title="connectors.connectors.OutputConnector.connect"><code class="xref py py-meth docutils literal"><span class="pre">connect()</span></code></a> method of the output connector <code class="xref py py-meth docutils literal"><span class="pre">get_sweep()</span></code> with the input connector <code class="xref py py-meth docutils literal"><span class="pre">set_input()</span></code> from the system.
The <a class="reference internal" href="core_reference.html#connectors.connectors.OutputConnector.connect" title="connectors.connectors.OutputConnector.connect"><code class="xref py py-meth docutils literal"><span class="pre">connect()</span></code></a> method returns the instance, to which the connector belongs.
This way, the instantiation of a processing class and the connection of one of its connectors can be done in one line, like this example shows.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>
    <span class="n">sweep</span> <span class="o">=</span> <span class="n">SweepGenerator</span><span class="p">()</span><span class="o">.</span><span class="n">get_sweep</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">set_input</span><span class="p">)</span>

</pre></div>
</div>
<p>Instantiating the fourier transform classes is straight forward now.
Note, that this time, the <a class="reference internal" href="core_reference.html#connectors.connectors.SingleInputConnector.connect" title="connectors.connectors.SingleInputConnector.connect"><code class="xref py py-meth docutils literal"><span class="pre">connect()</span></code></a> method of the input connectors are called with an output connector as a parameter, while it is the other way around, during the instantiation of the sweep generator.
Both ways are possible.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>
    <span class="n">excitation_fft</span> <span class="o">=</span> <span class="n">FourierTransform</span><span class="p">()</span><span class="o">.</span><span class="n">set_signal</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">sweep</span><span class="o">.</span><span class="n">get_sweep</span><span class="p">)</span>
    <span class="n">response_fft</span> <span class="o">=</span> <span class="n">FourierTransform</span><span class="p">()</span><span class="o">.</span><span class="n">set_signal</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">get_output</span><span class="p">)</span>

</pre></div>
</div>
<p>The class for dividing the two spectrums is created without connecting any of its connectors in the same line.
Since two of its connectors have to be connected, the connections are established in separate but similar lines, which improves the readability of the code.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>
    <span class="n">transfer_function</span> <span class="o">=</span> <span class="n">TransferFunction</span><span class="p">()</span>
    <span class="n">transfer_function</span><span class="o">.</span><span class="n">set_excitation</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">excitation_fft</span><span class="o">.</span><span class="n">get_spectrum</span><span class="p">)</span>
    <span class="n">transfer_function</span><span class="o">.</span><span class="n">set_response</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">response_fft</span><span class="o">.</span><span class="n">get_spectrum</span><span class="p">)</span>

</pre></div>
</div>
<p>Finally, the plot is created and shown.
In addition to the measured transfer function, the plot also shows the spectrum of the system’s impulse response, so it can be seen how the measured transfer function deviates from the expected spectrum.</p>
<img src="_images/graphviz-94151810a6ede50bb48103ad29501e0cd165bb5e.png" alt="digraph Plot{
   rankdir=LR;
   ir -&gt; system;
   ir -&gt; fft0 -&gt; plot;
   generator -&gt; system -&gt; fft1 -&gt; division -&gt; plot;
   generator -&gt; fft2 -&gt; division;
   ir [label=&quot;Impulse response&quot;, shape=octagon, color=green];
   fft0 [label=&quot;FFT&quot;, shape=box, color=green];
   generator [label=&quot;Signal generator&quot;, shape=hexagon];
   system [label=&quot;{|System|}&quot;, shape=record, color=red];
   fft1 [label=&quot;FFT&quot;, shape=box, color=blue];
   division [label=&quot;÷&quot;, shape=box, color=blue];
   fft2 [label=&quot;FFT&quot;, shape=box, color=blue];
   plot [label=&quot;Plot&quot;, shape=parallelogram];
   {rank=same; ir, system};
   {rank=same; fft0, fft1, fft2};
}" />
<p>Adding the measured transfer function is done through connections, just like the other connections, that have been established before.
It is noteworthy though, how the spectrum of the impulse response is added by simply calling the respective methods and without relying on the functionality of the <em>Connectors</em> package.
This shows, that the decorated methods can still be used as normal methods, even when they are extended with the functionality of a connector.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>
    <span class="n">magnitude_plot</span> <span class="o">=</span> <span class="n">MagnitudePlot</span><span class="p">()</span>
    <span class="n">magnitude_plot</span><span class="o">.</span><span class="n">add_spectrum</span><span class="p">(</span><span class="n">FourierTransform</span><span class="p">(</span><span class="n">impulse_response</span><span class="p">)</span><span class="o">.</span><span class="n">get_spectrum</span><span class="p">())</span>
    <span class="n">transfer_function</span><span class="o">.</span><span class="n">get_transfer_function</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">magnitude_plot</span><span class="o">.</span><span class="n">add_spectrum</span><span class="p">)</span>
    <span class="n">magnitude_plot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

</pre></div>
</div>
<p>This results in the following plot.
The measured transfer function matches well with the spectrum of the original impulse response, but especially at low frequencies, there are slight deviations.
Above 20kHz, the two measured frequency response becomes highly inaccurate, which is because the sweep has not excited these frequencies, so the computation of the transfer function becomes a division by zero.</p>
<img alt="_images/transfer_function1.png" src="_images/transfer_function1.png" />
<p>To demonstrate the automated updating of data in a processing network, the start frequency of the sweep is changed and the plot is shown again.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>
    <span class="n">sweep</span><span class="o">.</span><span class="n">set_start_frequency</span><span class="p">(</span><span class="mf">1000.0</span><span class="p">)</span>
    <span class="n">magnitude_plot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The following plot shows the effect of raising the start frequency of the sweep to a value in the plotted frequency range.
Since the low frequencies are no longer properly excited, the measurement of the tranfer function is invalid here aswell.</p>
<img alt="_images/transfer_function2.png" src="_images/transfer_function2.png" />
</div>
<div class="section" id="the-complete-script">
<h2>3.8. The complete script<a class="headerlink" href="#the-complete-script" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">connectors</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span>

<span class="n">sampling_rate</span> <span class="o">=</span> <span class="mf">44100.0</span>


<span class="k">class</span> <span class="nc">LinearSystem</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">impulse_response</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__impulse_response</span> <span class="o">=</span> <span class="n">impulse_response</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__input</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="nd">@connectors.Input</span><span class="p">(</span><span class="s2">&quot;get_output&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__input</span> <span class="o">=</span> <span class="n">signal</span>

    <span class="nd">@connectors.Output</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">get_output</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__impulse_response</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__input</span><span class="p">)]</span>


<span class="k">class</span> <span class="nc">SweepGenerator</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_frequency</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span> <span class="n">stop_frequency</span><span class="o">=</span><span class="mf">20000.0</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__start_frequency</span> <span class="o">=</span> <span class="n">start_frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__stop_frequency</span> <span class="o">=</span> <span class="n">stop_frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__length</span> <span class="o">=</span> <span class="n">length</span>

    <span class="nd">@connectors.Input</span><span class="p">(</span><span class="s2">&quot;get_sweep&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_start_frequency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequency</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__start_frequency</span> <span class="o">=</span> <span class="n">frequency</span>

    <span class="nd">@connectors.Output</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">get_sweep</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">f0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__start_frequency</span>
        <span class="n">fT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stop_frequency</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__length</span> <span class="o">/</span> <span class="n">sampling_rate</span>               <span class="c1"># the duration of the signal</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">sampling_rate</span><span class="p">)</span>   <span class="c1"># an array with the time samples</span>
        <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">fT</span> <span class="o">-</span> <span class="n">f0</span><span class="p">)</span> <span class="o">/</span> <span class="n">T</span>                               <span class="c1"># the &quot;sweep rate&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">f0</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">FourierTransform</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__signal</span> <span class="o">=</span> <span class="n">signal</span>

    <span class="nd">@connectors.Input</span><span class="p">(</span><span class="s2">&quot;get_spectrum&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__signal</span> <span class="o">=</span> <span class="n">signal</span>

    <span class="nd">@connectors.Output</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">get_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__signal</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__signal</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">spectrum</span>


<span class="k">class</span> <span class="nc">TransferFunction</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">excitation</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">response</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__excitation</span> <span class="o">=</span> <span class="n">excitation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__response</span> <span class="o">=</span> <span class="n">response</span>

    <span class="nd">@connectors.Input</span><span class="p">(</span><span class="s2">&quot;get_transfer_function&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_excitation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__excitation</span> <span class="o">=</span> <span class="n">signal</span>

    <span class="nd">@connectors.Input</span><span class="p">(</span><span class="s2">&quot;get_transfer_function&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__response</span> <span class="o">=</span> <span class="n">signal</span>

    <span class="nd">@connectors.Output</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">get_transfer_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__response</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__excitation</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MagnitudePlot</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__spectrums</span> <span class="o">=</span> <span class="n">connectors</span><span class="o">.</span><span class="n">MultiInputData</span><span class="p">()</span>

    <span class="nd">@connectors.MultiInput</span><span class="p">(</span><span class="s2">&quot;show&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">add_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spectrums</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>

    <span class="nd">@add_spectrum.remove</span>
    <span class="k">def</span> <span class="nf">remove_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_id</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spectrums</span><span class="p">[</span><span class="n">data_id</span><span class="p">]</span>

    <span class="nd">@add_spectrum.replace</span>
    <span class="k">def</span> <span class="nf">replace_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_id</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__spectrums</span><span class="p">[</span><span class="n">data_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">spectrum</span>

    <span class="nd">@connectors.Output</span><span class="p">(</span><span class="n">parallelization</span><span class="o">=</span><span class="n">connectors</span><span class="o">.</span><span class="n">Parallelization</span><span class="o">.</span><span class="n">SEQUENTIAL</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spectrums</span><span class="p">:</span>
            <span class="n">x_axis_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sampling_rate</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__spectrums</span><span class="p">[</span><span class="n">d</span><span class="p">]))</span>
            <span class="n">magnitude</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__spectrums</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
            <span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_axis_data</span><span class="p">,</span> <span class="n">magnitude</span><span class="p">)</span>
        <span class="n">pyplot</span><span class="o">.</span><span class="n">loglog</span><span class="p">()</span>
        <span class="n">pyplot</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mf">20.0</span><span class="p">,</span> <span class="n">sampling_rate</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
        <span class="n">pyplot</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">)</span>
        <span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">impulse_response</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">impulse_response</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">system</span> <span class="o">=</span> <span class="n">LinearSystem</span><span class="p">(</span><span class="n">impulse_response</span><span class="p">)</span>

    <span class="n">sweep</span> <span class="o">=</span> <span class="n">SweepGenerator</span><span class="p">()</span><span class="o">.</span><span class="n">get_sweep</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">set_input</span><span class="p">)</span>

    <span class="n">excitation_fft</span> <span class="o">=</span> <span class="n">FourierTransform</span><span class="p">()</span><span class="o">.</span><span class="n">set_signal</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">sweep</span><span class="o">.</span><span class="n">get_sweep</span><span class="p">)</span>
    <span class="n">response_fft</span> <span class="o">=</span> <span class="n">FourierTransform</span><span class="p">()</span><span class="o">.</span><span class="n">set_signal</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">get_output</span><span class="p">)</span>

    <span class="n">transfer_function</span> <span class="o">=</span> <span class="n">TransferFunction</span><span class="p">()</span>
    <span class="n">transfer_function</span><span class="o">.</span><span class="n">set_excitation</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">excitation_fft</span><span class="o">.</span><span class="n">get_spectrum</span><span class="p">)</span>
    <span class="n">transfer_function</span><span class="o">.</span><span class="n">set_response</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">response_fft</span><span class="o">.</span><span class="n">get_spectrum</span><span class="p">)</span>

    <span class="n">magnitude_plot</span> <span class="o">=</span> <span class="n">MagnitudePlot</span><span class="p">()</span>
    <span class="n">magnitude_plot</span><span class="o">.</span><span class="n">add_spectrum</span><span class="p">(</span><span class="n">FourierTransform</span><span class="p">(</span><span class="n">impulse_response</span><span class="p">)</span><span class="o">.</span><span class="n">get_spectrum</span><span class="p">())</span>
    <span class="n">transfer_function</span><span class="o">.</span><span class="n">get_transfer_function</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">magnitude_plot</span><span class="o">.</span><span class="n">add_spectrum</span><span class="p">)</span>
    <span class="n">magnitude_plot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="n">sweep</span><span class="o">.</span><span class="n">set_start_frequency</span><span class="p">(</span><span class="mf">1000.0</span><span class="p">)</span>
    <span class="n">magnitude_plot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="core_reference.html"
                        title="previous chapter">2. Reference: The core functionalities</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="macro_reference.html"
                        title="next chapter">4. Reference: Macro connectors for encapsulating processing networks in a class</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="macro_reference.html" title="4. Reference: Macro connectors for encapsulating processing networks in a class"
             >next</a> |</li>
        <li class="right" >
          <a href="core_reference.html" title="2. Reference: The core functionalities"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Connectors 1.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Jonas Schulte-Coerne.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.7.
    </div>
  </body>
</html>